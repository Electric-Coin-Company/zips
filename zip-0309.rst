::

  ZIP: 309
  Title: Add support for zk-Channels protocol
  Authors: J. Ayo Akinyele <ayo@zk-Channelslabs.io>
           Colleen Swanson <swan@zk-Channelslabs.io>
           Raphael Toledo <contat@raphael-toledo.com>
  Credits: Ian Miers <imiers@z.cash>
           Matthew Green <mgreen@z.cash>
  Category: Informational
  Created: 2019-07-15
  License: MIT


Terminology
===========

The key words "MUST" and "MUST NOT" in this document are to be interpreted as described in RFC 2119. [#RFC2119]_

Abstract
========

This proposal specifies three possible approaches for integrating the zk-Channels protocol [#zk-Channels-paper]_ into Zcash.

Motivation
==========

Layer 2 protocols like Lightning enable scalable payments for Bitcoin but lack the mechanisms to provide strong privacy guarantees on the payment network. Zcash offers private transactions but currently lacks features that would enable a Lightning-style payment channel. This proposal specifies an integration of the zkChannel privacy-preserving payment channel protocol on top of Zcash [#zk-Channels-paper]_.

zk-Channels high level Overview
========================

zk-Channels enables two parties, a customer and a merchant, to open an assymetric anonymous payment channel where only the customer may initiate channel opening and payments. While the channel opening and closure are broadcast on-chain, making the channel's participants at most pseudonymous, the payments are done directly between the customer and merchant offchain in an anonymous and unlinkable fashion.

The channel opening can be split in three phases: initialisation, activation and unlink:

1. in the initialisation phase, the customer and merchant set up the channel by agreeing on initial balances and auxiliary information.
2. in the activation phase, the merchant ensures that the channel has been properly funded and sends to the client a payment token to allow the customer to transfer funds.
3. the unlink phase goal is to unlink the channel opening with futher payments by performing a first unlinkable payment with null amount.

The off-chain payments is also split in three phases: setup, update state, and unmask.

1. in the setup phase, the customer generates a new channel state privately and sends to the customer a payment request. The merchant checks checks this is not a double spend, and if so either accept or reject the new payment.
2. in the update state phase, the customer and merchant participate in a zk-protocol where the merchant agrees on the new payment, by signing blindy on the new channel state, while revoking the current state.
3. in the unmask phase, the customer and merchant gets the payment and revocation token to close the zk-channel onchain.

The channel can be closed in three different ways:

- unilaterally by the merchant. In that case, the merchant uses the closing information exchanged in the channel initialisation to broadcast an expiry transaction onchain; the total amount is time-locked.

  a. during the time lock, the customer can broadcast a customer close which nullify the expiry transaction;
  b. after the time lock, the merchant can claim the funds.

- unilaterally by the customer. In that case, the customer uses the close authorization message received in a update state phase to broadcase a customer close transaction onchain; the merchant balance is sent directly to the merchant while the customer balance is time-locked.

  a. during the time lock, the customer balance can be disputed by the merchant, in case the customer closed on an outdated state, by revealing the revocation secret. In that case, all funds go to the merchant;
  b. after the time lock, the customer can claim the funds.

- mutually. In that case, the customer and merchant exchange information to generate a multisig transaction closing the channel.

1. General requirements for zk-Channels protocol
------------------------------------------------

zk-Channels private payment channels require the following capabilities to provide anonymity properties for users on a payment network:

1. Ability to create a escrow transaction such that the transaction inputs are anonymous.
2. Ability to escrow funds to a multi-signature style address via non-malleable transactions.
3. Ability to specify relative time locks for commitment transactions to support unilateral channel closing.
4. Ability to validate zk-Channels-specific opening and closing transactions:

  a. check the validity of randomized/blinded signature on the channel state in closing token;
  b. check the validity of revocation lock in the event of a channel dispute by merchant.

5. Ability to enforce a transaction flow thanks to Transparent ZCash Extensions [#zip-0222]
6. Ability to verify transaction outputs using WTPs such that:

  a. if customer-initiated closing, one output pays out to customer with a time lock (to allow merchant to dispute customer balance) and one output pays out to merchant immediately;
  b. if merchant-initiated closing, a single output pays the merchant the full balance of the channel with a time lock that allows for customer dispute.

**Channel Operation Assumptions.**
  - Channels funded by the customer alone and dual-funded channels are both supported.
  - Either the customer or the merchant can initiate channel closing.
  - If the customer initiates closing, then the merchant can dispute the closing transaction if they disagrees with the closing token in the closing transaction.
  - If the merchant initiates closing, the merchant posts a transaction claiming all the funds in the channel for themselves with a timelock. This gives the customer the opportunity to post their own valid closing transaction with the current channel balances. If the customer posts their own closing transaction, the merchant has an additional opportunity to dispute if necessary.

1.1 Customer and Merchant Signing Keys
--------------------------------------

The customer and the merchant both have key pairs from a suitable signature scheme to send and receive transactions. e.g. ECDSA or RedDSA signature key pairs. These are denoted as: ``<cust-pk>, <cust-sk>`` and ``<merch-pk>, <merch-sk>``, respectively, where ``pk`` stands for "public key" and ``sk`` stands for the corresponding "secret key".

The merchant must be able to issue blind signatures, for instance Pointcheval-Sanders blind signature, so they have an additional keypair; this keypair is denoted as:
``<MERCH-PK>, <MERCH-SK>``.

The customer key pair is specific to the channel and must not be reused. The merchant key pair is long term and should be used for all customer channels. 

1.2 Channel states
------------------

zk-Channels relies on the concept of *states*. When the customer initiates a payment, they query the merchant to accept a new state while revoking the current one.

The only zk-channel's invariants are the channel identifier ``<cid>``, and its participants' public keys. A channel state consists of:

- the channel id: ``<cid>``;
- the customer's public keys: ``<cust-pk>`` (defined in 1.1);
- the merchant's public keys: ``<merch-pk>, <MERCH-PK>`` (defined in 1.1);
- the customer's balance: ``<cust-balance>``, also called ``<initial-cust-balance>`` for the channel opening;
- the merchant's balance: ``<merch-balance>``, also called ``<initial-merch-balance>`` for the channel opening;
- the revocation lock: ``<rl>``, also called ``<initial-rl>`` for the channel opening, which is instantiated as a hash lock, ``<rl> = SHA256(<rs>)`` where ``<rs>`` is the revocation secret.

The revocation lock is needed by the merchant to dispute a customer close on an outdated state.


1.3 Opening a channel: Overview
-------------------------------
To open a channel, the customer and merchant exchange key information and set the channel identifier ``<cid>``. 

They agree on their respective initial balances ``<initial-cust-balance>`` and ``<initial-merch-balance>``, and may negotiate a claiming delay ``<delay>``.

The customer picks an inital revocation lock ``<initial-rl>``.

The customer and merchant escrow the necessary funds in a funding transaction, denoted ``escrow-tx``.

As such, the escrow transaction presents:

- an opening channel state ``<initial-state> = <cid>, <cust-pk>, <merch-pk>, <MERCH-PK>, <initial-cust-balance>, <initial-merch-balance>, <initial-rl>``;
- potentially additional information such as a delay <delay>.

1.4 Closing a channel: Overview
-------------------------------
A customer should be able to unilaterally close the channel by posting a ``cust-close-tx`` transaction. This transaction presents:

- a closing channel state ``<state> = <cid>, <cust-pk>, <merch-pk>, <MERCH-PK>, <cust-balance>, <merch-balance>, <rl>``;
- a unblinded signature from the merchant on the channel state: ``<merch-sig>`` such that ``PS_sig.Verify(<MERCH-PK>, <state>, <merch-sig>) = 1``.

If the transaction is validated and mined, <merch-balance> is sent to the merchant and <cust-balance> is locked for a delay <delay> during which the merchant can dispute the channel closing thanks to a ``dispute-tx`` transaction, and after which the customer can claim it thanks to a ``cust-claim-tx`` transaction.


The merchant can dispute a customer close by posting a ``dispute-tx`` transaction. This transaction presents:

- a revocation secret ``<rs>`` such that for the revocation lock ``<rl>`` posted in ``cust-close-tx`` we have ``<rl> = SHA256(<rs>)``.

If the transaction is validated and mined, the total balance (<cust-balance> + <merch-balance>) is sent to the merchant.


A merchant should be able to unilaterally close the channel by posting a closing transaction ``expiry-tx``. This transaction presents:

- a signature from the customer on the initial state: ``<cust-sig>`` such that ``RedDSA_sig.Verify(<cust-pk>, <initial-state>, <cust-sig>) = 1``.

If the transaction is validated and mined, the total balance is locked for a delay <delay> during which the customer can overwrite the spend with a ``cust-close-tx`` transaction, and after which the merchant can claim it thanks to a ``merch-claim-tx`` transaction.


The customer and merchant may also negotiate off-chain to form a *mutual close transaction*, ``mutual-close-tx``. This transaction presents:

- a truncated closing channel state ``<state>`` without the revocation lock and the merchant's blind signature public key;
- two signatures from the customer ``<cust-sig>`` and the merchant ``<merch-sig>`` on this truncated state such that ``RedDSA_sig.Verify(<cust-pk>, <state>, <cust-sig>) = 1`` and ``RedDSA_sig.Verify(<MERCH-PK>, <state>, <merch-sig>) = 1``.

If the transaction is validated and mined, the balance <cust-balance> is sent to the customer and the balance <merch-balance> is sent to the merchant.


2 zkChannel transactions
------------------------
We present in this section the individual transactions for opening and closing a zk-Channel as well as disputing and claiming funds of a zkChannel.

For simplicity, we describe the minimal information needed to understand the workflow, that is we show only the relevant part of the verify_tze functions and do not detail more than necessary the transaction structure.

2.1 Escrow transaction
----------------------
We present here the escrow transaction ``escrow-tx``:


============= ==============================
Field         Value
============= ==============================
...           ...
tx_in_count   2
tx_in         [<cust-input>, <merch-input>]
tx_out_count  0
tx_out        []
tze_in_count  0
tze_in        []
tze_out_count 1
tze_out       [<escrow-out>]
lock_time     0
...           ...
============================================

With,
 
- <cust-input> being a transparent address comprising an amount of <initial-cust-balance>.
- <merch-input> being a transparent address comprising an amount of <initial-merch-balance>.
- with <escrow-out> being a tze input:

  - amount = <initial-merch-balance> + <initial-cust-balance>
  - precondition =

    - tze_id = <zk-Channels-tze-id>
    - tze_mode = <escrow-mode>
    - tze_data_payload_len = 2*len(pk) + len(cid) + 32 + 2*64 
    - tze_data_payload = <cid> || <cust-pk> || <merch-pk> || <MERCH-PK> || <initial-rl> || <initial-cust-balance> || <initial-merch-balance>


An escrow transaction can either be spent by a mutual close, merchant expiry or customer close transaction.

2.1 Mutual close
----------------
We present here the mutual close transaction ``mutual-close-tx``:

============= ===============================
Field         Value
============= ===============================
...           ...
tx_in_count   0
tx_in         []
tx_out_count  2
tx_out        [<cust-output>, <merch-output>]
tze_in_count  1
tze_in        [<escrow-in>]
tze_out_count 0
tze_out       []
lock_time     0 // not used
...           ...
=============================================


With,
  - <escrow-in>:

    - prevout_hash =  <escrow-tx>
    - prevout_in = 0
    - witness =

      - tze_id = <zk-Channels-tze-id>
      - tze_mode = <escrow-mode>
      - tze_data_payload_len = 
      - tze_data_payload = <cid> || <cust-pk> || <merch-pk> || <cust-balance> || <merch-balance> || <cust-sig> || <merch-sig>

  - <cust-output> being a transparent address comprising an amount of <cust-balance>;
  - <merch-output> being a transparent address comprising an amount of <merch-balance>.

We describe here the part of tze_verify function defined on <zk-Channels-tze-id> type and mode <escrow-mode> relative to a mutual close. 

**tze_verify(zk-Channels-tze-id, escrow-mode, precondition, witness):**

- ...
- if mutual-close TODO
  
  - // *Define variables*
  - init-cid || init-cust-pk || init-merch-pk || init-MERCH-PK || init-rl || init-cust-balance || init-merch-balance = precondition
  - cid || cust-pk || merch-pk || cust-balance || merch-balance || cust-sig || merch-sig = witness 
  - msg = cid || merch-balance || cust-balance
  - // *Verify variables consistency*
  - if init-cid != cid:

    - Return False

  - if init-cust-pk != cust-pk:

    - Return False


  - // *Verify signatures*
  
  - if Verify(<cust-pk>, <msg>, <cust-sig>) = 0

    - Return False

  - if Verify(<merch-pk>, <msg>, <merch-sig>) = 0

    - Return False


  - // *Verify transaction correctness*
  - if context.mutual-close.sender != <cust-pk> AND context.mutual-close-tx.sender != <merch-pk>:

    - Return False

  - if <cust-output>.amount != <cust-balance> OR <cust-output>.owner != <pk_C>:

    - Return False

  - if <merch-output>.amount != <merch-balance> OR <merch-output>.owner != <pk_M>:

    - Return False

  - Return True
- ...



A.3 Merchant close
------------------

Merchance close transaction <merch-close-tx-id>
...
tx_in_count = 0
tx_in = []
tx_out_count = 0
tx_out =  []
tze_in_count = 1
tze_in =  <escrow-in>
tze_out_count = 1
tze_out =  <merch-close-out>
lock_time =  0
...

with <escrow-in>
- prevout_hash = <escrow-tx-id>
- prevout_in = 0 // there is only 1 tze in this example
- witness =
  - tze_id = <zk-Channels_tze_id>
  - tze_mode = <escrow-mode> // we need to keep the same mode
  - tze_data_payload_len =
  - tze_data_payload = <expiry-signature_C> // potentially adding <delay> if channel specific

with <merch-close-out>
- amount = <merch-balance>_0 + <cust-balance>_0
- precondition =
  - tze_id = <zk-Channels_tze_id>
  - tze_mode = <merch-close-mode>
  - tze_data_payload_len =
  - tze_data_payload = <pk_C> || <pk_M> || <cid> || <rl>_0 || <merch-balance>_0 || <cust-balance>_0 // potentially adding <n_0> for reconciliation

The tze_verify functions works as follows:
- if <merch-close-out>.precondition.mode = <merch-close-mode>
// Standard check (add delay if channel specific)
  - if sender != <pk_M>:
    - Return False
  - <msg> = <pk_C> || <pk_M> || <cid> || <rl>_0 || <merch-balance>_0 || <cust-balance>_0
  - if Verify(<pk_M>, <msg>, <expiry-signature_C>) = 0
    - Return False
  // Check that information is transferred correctly from tze_in to tze_out
  - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<cid>] != <merch-close-out>.precondition.tze_data_payload[<cid>]:
    - Return False
  - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<pk_C>] != <merch-close-out>.precondition.tze_data_payload[<pk_C>]:
    - Return False
  - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<pk_M>] != <merch-close-out>.precondition.tze_data_payload[<pk_M>]:
    - Return False
  - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<rl>_0] != <merch-close-out>.precondition.tze_data_payload[<rl>_0]:
    - Return False
  - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<cust-balance>_0] != <merch-close-out>.precondition.tze_data_payload[<cust-balance>_0]:
    - Return False
  - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<merch-balance>_0] != <merch-close-out>.precondition.tze_data_payload[<merch-balance>_0]:
    - Return False
  - Return True

A.4 Merchant claim

Merchance claim transaction <merch-claim-tx-id>
...
tx_in_count = 0
tx_in = []
tx_out_count = 1
tx_out =  [<merch-claim>]
tze_in_count = 1
tze_in =  <merch-close-in>
tze_out_count = 0
tze_out =  []
lock_time =  0
...

with <merch-close-in>
- prevout_hash = <merch-close-tx-id>
- prevout_in = 0 // there is only 1 tze in this example
- witness =
  - tze_id = <zk-Channels_tze_id>
  - tze_mode = <merch-close-mode> // we need to keep the same mode
  - tze_data_payload_len =
  - tze_data_payload =  <merch-claim-tag> // potentially adding <delay> if channel specific


The tze_verify functions works as follows:
- if <merch-close-in>.witness.tze_data_payload = <merch-claim-tag>
   // Standard check (add delay if channel specific)
  - if sender != <pk_M>:
    - Return False
  - if context.<block-height> < <merch-close-tx-id>.<context>.<block-height> + DELAY // replace with channel specific delay if needs be
    - Return False
  - Return True

A.5 Customer close

  ...
tx_in_count = 0
tx_in = []
tx_out_count = 1
tx_out = <merch-output>
tze_in_count = 1
tze_in = <escrow-in> OR <merch-close-in>
tze_out_count = 1
tze_out = <cust-close-out>
lock_time = 0 // not used
...

with <escrow-in>:
- prevout_hash =  <escrow-tx-id>
- prevout_in = 0 // there is only 1 tze in this example
- witness =
 - tze_id = <zk-Channels_tze_id>
 - tze_mode = <escrow-mode> // we need to keep the same mode
 - tze_data_payload_len = 
 - tze_data_payload =  <signature_M> || <cid> || <rl>_i || <merch-balance>_i || <cust-balance>_i // potentially adding <n_i> for reconciliation

with <merch-close-in>:
- prevout_hash =  <escrow-tx-id>
- prevout_in = 0 // there is only 1 tze in this example
- witness =
  - tze_id = <zk-Channels_tze_id>
  - tze_mode = <merch-close-mode> // we need to keep the same mode
  - tze_data_payload_len =
  - tze_data_payload = <signature_M> || <cid> || <rl>_i || <merch-balance>_i || <cust-balance>_i // potentially adding <n_i> for reconciliation

with <cust-close-out>:
- amount = <cust-balance>_i
- precondition =
 - tze_id = <zk-Channels_tze_id>
 - tze_mode = <cust-close-mode> // change of mode for cust close
 - tze_data_payload_len =  
 - tze_data_payload = <pk_C> || <pk_M> || <cid> || <rl>_i || <cust-balance>_i // potentially adding <n_i> for reconciliation, as well as <delay> if channel specific


The tze_verify functions works as follows:
- if <cust-close-out>.precondition.mode = <cust-close-mode>
  // Standard check (add delay if channel specific)
  - if sender != <pk_C>:
    - Return False
  - <msg> = <pk_C> || <pk_M> || <cid> || <rl>_i || <merch-balance>_i || <cust-balance>_i
  - if Verify(<pk_M>, <msg>, <signature_M>) = 0
    - Return False
  // Check that amounts and receiver are correct
  - if <merch-output>.amount != <merch-balance>_i OR <merch-output>.owner != <pk_M>:
    - Return False
  - if <cust-close-out>.amount != <cust-balance>_i OR <cust-close-out>.owner != <pk_C> OR <rl>_i NOT IN <cust-close-out>.precondition:
    - Return False
  // Check that information is transferred correctly from tze_in to tze_out
  - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<cid>] != <cust-close-out>.precondition.tze_data_payload[<cid>]:
    - Return False
 - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<pk_C>] != <cust-close-out>.precondition.tze_data_payload[<pk_C>]:
    - Return False
  - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<pk_M>] != <cust-close-out>.precondition.tze_data_payload[<pk_M>]:
    - Return False
  - if <escrow-in>.precondition.tze_data_payload[<rl>_i] != <cust-close-out>.precondition.tze_data_payload[<rl>_i]:
    - Return False
  - if <escrow-id>.precondition.tze_data_payload[<cust-balance>_i] != <cust-close-out>.precondition.tze_data_payload[<cust-balance>_i]:
    - Return False
  - Return True

A.6 Customer claim

Customer claim transaction <cust-claim-tx-id>
...
tx_in_count = 0
tx_in = []
tx_out_count = 1
tx_out =  [<cust-claim>]
tze_in_count = 1
tze_in =  <cust-close-in>
tze_out_count = 0
tze_out =  []
lock_time =  0
...


with <cust-close-in>
- prevout_hash = <cust-close-tx-id>
- prevout_in = 0 // there is only 1 tze in this example
- witness =
  - tze_id = <zk-Channels_tze_id>
  - tze_mode = <cust-close-mode> // we need to keep the same mode
  - tze_data_payload_len =
  - tze_data_payload = <cust-claim-tag> // potentially adding <delay> if 
channel specific

The tze_verify functions works as follows:
- if <cust-close-in>.witness.tze_data_payload = <cust-claim-tag>
// Standard check (add delay if channel specific)
  - if sender != <pk_C>:
    - Return False
  - if context.<block-height> < <cust-close-tx-id>.<context>.<block-height> + DELAY // replace with channel specific delay if needs be
    - Return False
  - Return True

A.7 Merchant dispute

Customer claim transaction <cust-claim-tx-id>
...
tx_in_count = 0
tx_in = []
tx_out_count = 1
tx_out =  [<merch-dispute>]
tze_in_count = 1
tze_in =  <cust-close-in>
tze_out_count = 0
tze_out =  []
lock_time =  0
...


with <cust-close-in>
- prevout_hash = <cust-close-tx-id>
- prevout_in = 0 // there is only 1 tze in this example
- witness =
  - tze_id = <zk-Channels_tze_id>
  - tze_mode = <cust-close-mode> // we need to keep the same mode
  - tze_data_payload_len =
  - tze_data_payload =  <merch-dispute-tag> || <rs>_i

The tze_verify functions works as follows:
- if <cust-close-in>.witness.tze_data_payload[0] = <merch-dispute-tag>
  // Standard check (add delay if channel specific)
  - if sender != <pk_M>:
    - Return False
  - if <cust-close-tx-id>.pprecondition.tze_data_payload[prevout_in].<rl>_i != HASH(<cust-close-in>.witness.tze_data_payload.<rs>_i)
    - Return False
  - Return True


B TZE_VERIFY functions:

B.1 Escrow
- if <merch-close-out>.precondition.mode = <merch-close-mode>
   // Standard check (add delay if channel specific)
   - if sender != <pk_M>:
    - Return False
   - <msg> = <pk_C> || <pk_M> || <cid> || <rl>_0 || <merch-balance>_0 || <cust-balance>_0
   - if Verify(<pk_M>, <msg>, <expiry-signature_C>) = 0
    - Return False
   // Check that information is transferred correctly from tze_in to tze_out
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<cid>] != <merch-close-out>.precondition.tze_data_payload[<cid>]:
    - Return False
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<pk_C>] != <merch-close-out>.precondition.tze_data_payload[<pk_C>]:
    - Return False
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<pk_M>] != <merch-close-out>.precondition.tze_data_payload[<pk_M>]:
    - Return False
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<rl>_0] != <merch-close-out>.precondition.tze_data_payload[<rl>_0]:
    - Return False
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<cust-balance>_0] != <merch-close-out>.precondition.tze_data_payload[<cust-balance>_0]:
    - Return False
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<merch-balance>_0] != <merch-close-out>.precondition.tze_data_payload[<merch-balance>_0]:
    - Return False
  - Return True
- if <cust-close-out>.precondition.mode = <cust-close-mode>
   // Standard check (add delay if channel specific)
   - if sender != <pk_C>:
    - Return False
   - <msg> = <pk_C> || <pk_M> || <cid> || <rl>_i || <merch-balance>_i || <cust-balance>_i
   - if Verify(<pk_M>, <msg>, <signature_M>) = 0
    - Return False
   // Check that amounts and receiver are correct
   - if <merch-output>.amount != <merch-balance>_i OR <merch-output>.owner != <pk_M>:
    - Return False
   - if <cust-close-out>.amount != <cust-balance>_i OR <cust-close-out>.owner != <pk_C> OR <rl>_i NOT IN <cust-close-out>.precondition:
    - Return False
   // Check that information is transferred correctly from tze_in to tze_out
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<cid>] != <cust-close-out>.precondition.tze_data_payload[<cid>]:
    - Return False
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<pk_C>] != <cust-close-out>.precondition.tze_data_payload[<pk_C>]:
    - Return False
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<pk_M>] != <cust-close-out>.precondition.tze_data_payload[<pk_M>]:
    - Return False
   - if <escrow-in>.precondition.tze_data_payload[<rl>_i] != <cust-close-out>.precondition.tze_data_payload[<rl>_i]:
    - Return False
   - if <escrow-id>.precondition.tze_data_payload[<cust-balance>_i] != <cust-close-out>.precondition.tze_data_payload[<cust-balance>_i]:
    - Return False
  - Return True
- if witness[0] = <mutual-close-tag>
  - <msg> = <pk_C> || <pk_M> || <cid> || <rl>_0 || <merch-balance>_0 || <cust-balance>_0 || <merch-balance>_m || <cust-balance>_m
  - if Verify(<pk_C>, <msg>, <signature_C>) = 0
   - Return False
  - if Verify(<pk_M>, <msg>, <signature_M>) = 0
   - Return False
  - if <merch-output>.amount != <merch-balance>_m OR <merch-output>.owner != <pk_M>:
   - Return False
  - if <cust-output>.amount != <cust-balance>_m  OR <cust-output>.owner != <pk_C>:
   - Return False
  - Return True
- Return False


B.2 Customer close
- if <cust-close-in>.witness.tze_data_payload = <cust-claim-tag>
   // Standard check (add delay if channel specific)
   - if sender != <pk_C>:
    - Return False
   - if context.<block-height> < <cust-close-tx-id>.<context>.<block-height>   DELAY // replace with channel specific delay if needs be
    - Return False
   - Return True
- if <cust-close-in>.witness.tze_data_payload[0] = <merch-dispute-tag>
   // Standard check (add delay if channel specific)
   - if sender != <pk_M>:
    - Return False
   - if <cust-close-tx-id>.pprecondition.tze_data_payload[prevout_in].<rl>_i != HASH(<cust-close-in>.witness.tze_data_payload.<rs>_i)
    - Return False
   - Return True
- Return False


B.3 Merchant close
- if <merch-close-in>.witness.tze_data_payload = <merch-claim-tag>
   // Standard check (add delay if channel specific)
   - if sender != <pk_M>:
    - Return False
   - if context.<block-height> < <merch-close-tx-id>.<context>.<block-height>   DELAY // replace with channel specific delay if needs be
    - Return False
   - Return True
- if <cust-close-out>.precondition.mode = <cust-close-mode>
   // Standard check (add delay if channel specific)
   - if sender != <pk_C>:
    - Return False
   - <msg> = <pk_C> || <pk_M> || <cid> || <rl>_i || <merch-balance>_i || <cust-balance>_i
   - if Verify(<pk_M>, <msg>, <signature_M>) = 0
    - Return False
   // Check that amounts and receiver are correct
   - if <merch-output>.amount != <merch-balance>_i OR <merch-output>.owner != <pk_M>:
    - Return False
   - if <cust-close-out>.amount != <cust-balance>_i OR <cust-close-out>.owner != <pk_C> OR <rl>_i NOT IN <cust-close-out>.precondition:
    - Return False
   // Check that information is transferred correctly from tze_in to tze_out
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<cid>] != <cust-close-out>.precondition.tze_data_payload[<cid>]:
    - Return False
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<pk_C>] != <cust-close-out>.precondition.tze_data_payload[<pk_C>]:
    - Return False
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<pk_M>] != <cust-close-out>.precondition.tze_data_payload[<pk_M>]:
    - Return False
   - if <escrow-in>.precondition.tze_data_payload[<rl>_i] != <cust-close-out>.precondition.tze_data_payload[<rl>_i]:
    - Return False
   - if <escrow-id>.precondition.tze_data_payload[<cust-balance>_i] != <cust-close-out>.precondition.tze_data_payload[<cust-balance>_i]:
    - Return False
   - Return True

.. [#BoltWTP] _`Bolt WTP implementation for Zcash <https://github.com/boltlabs-inc/librustzcash>`

References
==========

.. [#RFC2119] `Key words for use in RFCs to Indicate Requirement Levels <https://tools.ietf.org/html/rfc2119>`_
.. [#bolt-paper]  `Bolt: Anonymous Payment Channels for Decentralized Currencies <https://eprint.iacr.org/2016/701>`_
.. [#zip-0222]  `ZIP 222: Transparent Zcash Extensions (Draft) <https://github.com/zcash/zips/pull/248>`_