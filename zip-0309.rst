::

  ZIP: 309
  Title: Add support for Blind Off-chain Lightweight Transactions (Bolt) protocol
  Authors: J. Ayo Akinyele <ayo@boltlabs.io>
           Colleen Swanson <swan@boltlabs.io>
  Credits: Ian Miers <imiers@z.cash>
           Matthew Green <mgreen@z.cash>
  Category: Informational
  Created: 2019-07-15
  License: MIT


Terminology
===========

The key words "MUST" and "MUST NOT" in this document are to be interpreted as described in RFC 2119. [#RFC2119]_

Abstract
========

This proposal specifies three possible approaches for integrating the Blind Off-chain Lightweight Transaction (Bolt) protocol [#bolt-paper]_ into Zcash.

Motivation
==========

Layer 2 protocols like Lightning enable scalable payments for Bitcoin but lack the mechanisms to provide strong privacy guarantees on the payment network. Zcash offers private transactions but currently lacks features that would enable a Lightning-style payment channel. This proposal specifies an integration of the Bolt privacy-preserving payment channel protocol on top of Zcash [#bolt-paper]_.

BOLT high level Overview
========================

BOLT enables two parties, a customer and a merchant, to open an assymetric anonymous payment channel where only the customer may initiate channel opening and payments. While the channel opening and closure are broadcast on-chain, making the channel's participants at most pseudonymous, the payments are done directly between the customer and merchant offchain in an anonymous and unlinkable fashion.

The channel opening can be split in three phases: initialisation, activation and unlink.
 1. in the initialisation phase, the customer and merchant set up the channel id ``<channel-id>`` and exchange,
  a. their initial contributions to the channel, called resp. customer and merchant's balances, as well as a revocation lock and nonce for the current state ; ``<channel-state>_0 = < <channel-id>, <channel-nonce>_0, <revocation-lock>_0, <balance-merch>_0, <balance-cust>_0 >``
  b. information to close the channel, using signatures on this initial channel state;
  c. information to mutually fund the channel, potentially with the help of multi-signature.
 2. in the activation phase, the merchant,
  a. ensures that the channel has been properly funded;
  b. sends to the client a payment token to allow the customer to transfer funds.
 3. the unlink phase goal is to unlink the channel opening with futher payments by performing a first unlinkable payment with null amount.

The off-chain payments is also split in three phases: setup, update state, and unmask. For a payment of ``<epsilon>``, we have,
 1. in the setup phase,
  a. the customer generates a new channel state privately, corresponding to the customer and merchant new balances, a state nonce and revocation lock:``<channel-state>_{i+1} = (<channel-id>, <channel-nonce>_{i+1}, <revocation-lock>_{i+1}, <balance-merch>_{i+1}, <balance-cust>_{i+1})`` with ``<balance-merch>_{i+1}=<balance-merch>_i + <epsilon>``, ``<balance-cust>_{i+1}=<balance-cust>_i - <epsilon>``, ``<revocation-lock> = HASH(<revocation-secret>)``);
  b. the customer then sends to the merchant the current channel state nonce ``<channel-nonce>_i`` as well as the amount to transfer <epsilon>;
  c. the merchant checks the nonce has not been spent before, to prevent double spent, and if so either accept or reject the new payment.
 2. in the update state,
  a. the customer shares to the merchant commitments on the new channel state ``<channel-state>_{i+1}``, new close authorization message ``<channel-state>_{i+1}`` and the current revocation lock ``<revocation-lock>_i`` as well as a blind version of the current state payment token ``<pay-token>_i`` and a non-interactive zero-knowledge proof of knowledge that the commited new state is well formed w.r.t. the current state and the new payment, the channel has sufficient fund, the commited close authorization message is well formed, the current state contains the opening of the commited revocation lock as well as the current nonce, and the blind payment token is valid on the current state.
  b. the merchant verifies the proof is valid, if so he adds the current nonce to the set of spent nonce otherwise aborts.
 3. in the unmask phase,
  a. the merchant blindly signs the new close authorization message and sends it to the customer;
  b. the customer unblinds and verifies the signature is valid. If so, he sends the current revocation lock and secret;
  c. the merchant verifies the revocation was not spent, to prevent double spending, and the secret corresponds to the lock. If so, he blindly sign the new channel state and sends it to the customer;
  d. the customer unblinds and verifies the signature is valid. If so, he sets it as the new payment token.

The channel can be closed in three different ways:
 - unilaterally by the merchant. In that case, the merchant uses the closing information exchanged in the channel initialisation to broadcast an expiry transaction onchain; the total amount is time-locked.
  a. during the time lock, the customer can broadcast a customer close which nullify the expiry transaction;
  b. after the time lock, the merchant can claim the funds.
 - unilaterally by the customer. In that case, the customer uses the close authorization message received in a update state phase to broadcase a customer close transaction onchain; the merchant balance is sent directly to the merchant while the customer balance is time-locked.
  a. during the time lock, the customer balance can be disputed by the merchant, in case the customer closed on an outdated state, by revealing the revocation secret. In that case, all funds go to the merchant;
  b. after the time lock, the customer can claim the funds.
 - mutually. In that case, the customer and merchant exchange information to generate a multisig transaction closing the channel.


Specification
=============
TODO
Add  list of what we need
- possibility for tze_verify to check output addresses of a transaction
- ...

Examples
========

A.1 Escrow transaction

...
tx_in_count = i_m+i_j
tx_in = < [merchant input addresses]_{i_m}, [customer input addresses]_{i_c}>
tx_out_count = j_m+j_c
tx_out = < [merchant output addresses]_{j_m}, [customer output addresses]_{j_c}>
tze_in_count = 0
tze_in = []
tze_out_count = 1
tze_out = <escrow-out>
lock_time = 0 // not used
...

with <escrow-out>:
- amount = <merch-balance>_0 + <cust-balance>_0
- precondition =
 - tze_id = <bolt_tze_id>
 - tze_mode = <escrow-mode>
 - tze_data_payload_len = 2*len(pk) + len(cid) + 32 + 2*64 
 - tze_data_payload = <pk_C> || <pk_M> || <cid> || <rl>_0 || <merch-balance>_0 || <cust-balance>_0 // potentially adding <n_0> for reconciliation

An escrow transaction can either be spent by a mutual close, merchant expiry or customer close.

A.2 Mutual close

...
tx_in_count = 0
tx_in = []
tx_out_count = 2
tx_out = <merch-output>, <cust-output>
tze_in_count = 1
tze_in = <escrow-in>
tze_out_count = 0
tze_out = []
lock_time = 0 // not used
...

with <escrow-in>:
- prevout_hash =  <escrow-tx-id>
- prevout_in = 0 // there is only 1 tze in this example
- witness =
 - tze_id = <bolt_tze_id>
 - tze_mode = <escrow-mode> // we need to keep the same mode
 - tze_data_payload_len = 
 - tze_data_payload = <mutual-close-tag> || <signature_C> || <signature_M> || <merch-balance>_m || <cust-balance>_m // potentially adding <n_0> for reconciliation

The tze_verify functions works as follows:
- if witness[0] = <mutual-close-tag>
  - <msg> = <pk_C> || <pk_M> || <cid> || <rl>_0 || <merch-balance>_0 || <cust-balance>_0 || <merch-balance>_m || <cust-balance>_m
  - if Verify(<pk_C>, <msg>, <signature_C>) = 0
   - Return False
  - if Verify(<pk_M>, <msg>, <signature_M>) = 0
   - Return False
  - if <merch-output>.amount != <merch-balance>_m OR <merch-output>.owner != <pk_M>:
   - Return False
  - if <cust-output>.amount != <cust-balance>_m  OR <cust-output>.owner != <pk_C>:
   - Return False
  - Return True

Note: in case of more than one input and output, we need to add in the tze_data_payload the addresses' index. if we want to split the balances, the tze_verificatoin must check that the sum of the split merch balances equal the mutual agreed merchant balance, and reciprocally for the customer's.

A.3 Merchant close

Merchance close transaction <merch-close-tx-id>
...
tx_in_count = 0
tx_in = []
tx_out_count = 0
tx_out =  []
tze_in_count = 1
tze_in =  <escrow-in>
tze_out_count = 1
tze_out =  <merch-close-out>
lock_time =  0
...

with <escrow-in>
- prevout_hash = <escrow-tx-id>
- prevout_in = 0 // there is only 1 tze in this example
- witness =
  - tze_id = <bolt_tze_id>
  - tze_mode = <escrow-mode> // we need to keep the same mode
  - tze_data_payload_len =
  - tze_data_payload = <expiry-signature_C> // potentially adding <delay> if channel specific

with <merch-close-out>
- amount = <merch-balance>_0 + <cust-balance>_0
- precondition =
  - tze_id = <bolt_tze_id>
  - tze_mode = <merch-close-mode>
  - tze_data_payload_len =
  - tze_data_payload = <pk_C> || <pk_M> || <cid> || <rl>_0 || <merch-balance>_0 || <cust-balance>_0 // potentially adding <n_0> for reconciliation

The tze_verify functions works as follows:
- if <merch-close-out>.precondition.mode = <merch-close-mode>
// Standard check (add delay if channel specific)
  - if sender != <pk_M>:
    - Return False
  - <msg> = <pk_C> || <pk_M> || <cid> || <rl>_0 || <merch-balance>_0 || <cust-balance>_0
  - if Verify(<pk_M>, <msg>, <expiry-signature_C>) = 0
    - Return False
  // Check that information is transferred correctly from tze_in to tze_out
  - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<cid>] != <merch-close-out>.precondition.tze_data_payload[<cid>]:
    - Return False
  - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<pk_C>] != <merch-close-out>.precondition.tze_data_payload[<pk_C>]:
    - Return False
  - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<pk_M>] != <merch-close-out>.precondition.tze_data_payload[<pk_M>]:
    - Return False
  - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<rl>_0] != <merch-close-out>.precondition.tze_data_payload[<rl>_0]:
    - Return False
  - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<cust-balance>_0] != <merch-close-out>.precondition.tze_data_payload[<cust-balance>_0]:
    - Return False
  - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<merch-balance>_0] != <merch-close-out>.precondition.tze_data_payload[<merch-balance>_0]:
    - Return False
  - Return True

A.4 Merchant claim

Merchance claim transaction <merch-claim-tx-id>
...
tx_in_count = 0
tx_in = []
tx_out_count = 1
tx_out =  [<merch-claim>]
tze_in_count = 1
tze_in =  <merch-close-in>
tze_out_count = 0
tze_out =  []
lock_time =  0
...

with <merch-close-in>
- prevout_hash = <merch-close-tx-id>
- prevout_in = 0 // there is only 1 tze in this example
- witness =
  - tze_id = <bolt_tze_id>
  - tze_mode = <merch-close-mode> // we need to keep the same mode
  - tze_data_payload_len =
  - tze_data_payload =  <merch-claim-tag> // potentially adding <delay> if channel specific


The tze_verify functions works as follows:
- if <merch-close-in>.witness.tze_data_payload = <merch-claim-tag>
   // Standard check (add delay if channel specific)
  - if sender != <pk_M>:
    - Return False
  - if context.<block-height> < <merch-close-tx-id>.<context>.<block-height> + DELAY // replace with channel specific delay if needs be
    - Return False
  - Return True

A.5 Customer close

  ...
tx_in_count = 0
tx_in = []
tx_out_count = 1
tx_out = <merch-output>
tze_in_count = 1
tze_in = <escrow-in> OR <merch-close-in>
tze_out_count = 1
tze_out = <cust-close-out>
lock_time = 0 // not used
...

with <escrow-in>:
- prevout_hash =  <escrow-tx-id>
- prevout_in = 0 // there is only 1 tze in this example
- witness =
 - tze_id = <bolt_tze_id>
 - tze_mode = <escrow-mode> // we need to keep the same mode
 - tze_data_payload_len = 
 - tze_data_payload =  <signature_M> || <cid> || <rl>_i || <merch-balance>_i || <cust-balance>_i // potentially adding <n_i> for reconciliation

with <merch-close-in>:
- prevout_hash =  <escrow-tx-id>
- prevout_in = 0 // there is only 1 tze in this example
- witness =
  - tze_id = <bolt_tze_id>
  - tze_mode = <merch-close-mode> // we need to keep the same mode
  - tze_data_payload_len =
  - tze_data_payload = <signature_M> || <cid> || <rl>_i || <merch-balance>_i || <cust-balance>_i // potentially adding <n_i> for reconciliation

with <cust-close-out>:
- amount = <cust-balance>_i
- precondition =
 - tze_id = <bolt_tze_id>
 - tze_mode = <cust-close-mode> // change of mode for cust close
 - tze_data_payload_len =  
 - tze_data_payload = <pk_C> || <pk_M> || <cid> || <rl>_i || <cust-balance>_i // potentially adding <n_i> for reconciliation, as well as <delay> if channel specific


The tze_verify functions works as follows:
- if <cust-close-out>.precondition.mode = <cust-close-mode>
  // Standard check (add delay if channel specific)
  - if sender != <pk_C>:
    - Return False
  - <msg> = <pk_C> || <pk_M> || <cid> || <rl>_i || <merch-balance>_i || <cust-balance>_i
  - if Verify(<pk_M>, <msg>, <signature_M>) = 0
    - Return False
  // Check that amounts and receiver are correct
  - if <merch-output>.amount != <merch-balance>_i OR <merch-output>.owner != <pk_M>:
    - Return False
  - if <cust-close-out>.amount != <cust-balance>_i OR <cust-close-out>.owner != <pk_C> OR <rl>_i NOT IN <cust-close-out>.precondition:
    - Return False
  // Check that information is transferred correctly from tze_in to tze_out
  - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<cid>] != <cust-close-out>.precondition.tze_data_payload[<cid>]:
    - Return False
 - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<pk_C>] != <cust-close-out>.precondition.tze_data_payload[<pk_C>]:
    - Return False
  - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<pk_M>] != <cust-close-out>.precondition.tze_data_payload[<pk_M>]:
    - Return False
  - if <escrow-in>.precondition.tze_data_payload[<rl>_i] != <cust-close-out>.precondition.tze_data_payload[<rl>_i]:
    - Return False
  - if <escrow-id>.precondition.tze_data_payload[<cust-balance>_i] != <cust-close-out>.precondition.tze_data_payload[<cust-balance>_i]:
    - Return False
  - Return True

A.6 Customer claim

Customer claim transaction <cust-claim-tx-id>
...
tx_in_count = 0
tx_in = []
tx_out_count = 1
tx_out =  [<cust-claim>]
tze_in_count = 1
tze_in =  <cust-close-in>
tze_out_count = 0
tze_out =  []
lock_time =  0
...


with <cust-close-in>
- prevout_hash = <cust-close-tx-id>
- prevout_in = 0 // there is only 1 tze in this example
- witness =
  - tze_id = <bolt_tze_id>
  - tze_mode = <cust-close-mode> // we need to keep the same mode
  - tze_data_payload_len =
  - tze_data_payload = <cust-claim-tag> // potentially adding <delay> if 
channel specific

The tze_verify functions works as follows:
- if <cust-close-in>.witness.tze_data_payload = <cust-claim-tag>
// Standard check (add delay if channel specific)
  - if sender != <pk_C>:
    - Return False
  - if context.<block-height> < <cust-close-tx-id>.<context>.<block-height> + DELAY // replace with channel specific delay if needs be
    - Return False
  - Return True

A.7 Merchant dispute

Customer claim transaction <cust-claim-tx-id>
...
tx_in_count = 0
tx_in = []
tx_out_count = 1
tx_out =  [<merch-dispute>]
tze_in_count = 1
tze_in =  <cust-close-in>
tze_out_count = 0
tze_out =  []
lock_time =  0
...


with <cust-close-in>
- prevout_hash = <cust-close-tx-id>
- prevout_in = 0 // there is only 1 tze in this example
- witness =
  - tze_id = <bolt_tze_id>
  - tze_mode = <cust-close-mode> // we need to keep the same mode
  - tze_data_payload_len =
  - tze_data_payload =  <merch-dispute-tag> || <rs>_i

The tze_verify functions works as follows:
- if <cust-close-in>.witness.tze_data_payload[0] = <merch-dispute-tag>
  // Standard check (add delay if channel specific)
  - if sender != <pk_M>:
    - Return False
  - if <cust-close-tx-id>.pprecondition.tze_data_payload[prevout_in].<rl>_i != HASH(<cust-close-in>.witness.tze_data_payload.<rs>_i)
    - Return False
  - Return True


B TZE_VERIFY functions:

B.1 Escrow
- if <merch-close-out>.precondition.mode = <merch-close-mode>
   // Standard check (add delay if channel specific)
   - if sender != <pk_M>:
    - Return False
   - <msg> = <pk_C> || <pk_M> || <cid> || <rl>_0 || <merch-balance>_0 || <cust-balance>_0
   - if Verify(<pk_M>, <msg>, <expiry-signature_C>) = 0
    - Return False
   // Check that information is transferred correctly from tze_in to tze_out
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<cid>] != <merch-close-out>.precondition.tze_data_payload[<cid>]:
    - Return False
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<pk_C>] != <merch-close-out>.precondition.tze_data_payload[<pk_C>]:
    - Return False
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<pk_M>] != <merch-close-out>.precondition.tze_data_payload[<pk_M>]:
    - Return False
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<rl>_0] != <merch-close-out>.precondition.tze_data_payload[<rl>_0]:
    - Return False
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<cust-balance>_0] != <merch-close-out>.precondition.tze_data_payload[<cust-balance>_0]:
    - Return False
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<merch-balance>_0] != <merch-close-out>.precondition.tze_data_payload[<merch-balance>_0]:
    - Return False
  - Return True
- if <cust-close-out>.precondition.mode = <cust-close-mode>
   // Standard check (add delay if channel specific)
   - if sender != <pk_C>:
    - Return False
   - <msg> = <pk_C> || <pk_M> || <cid> || <rl>_i || <merch-balance>_i || <cust-balance>_i
   - if Verify(<pk_M>, <msg>, <signature_M>) = 0
    - Return False
   // Check that amounts and receiver are correct
   - if <merch-output>.amount != <merch-balance>_i OR <merch-output>.owner != <pk_M>:
    - Return False
   - if <cust-close-out>.amount != <cust-balance>_i OR <cust-close-out>.owner != <pk_C> OR <rl>_i NOT IN <cust-close-out>.precondition:
    - Return False
   // Check that information is transferred correctly from tze_in to tze_out
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<cid>] != <cust-close-out>.precondition.tze_data_payload[<cid>]:
    - Return False
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<pk_C>] != <cust-close-out>.precondition.tze_data_payload[<pk_C>]:
    - Return False
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<pk_M>] != <cust-close-out>.precondition.tze_data_payload[<pk_M>]:
    - Return False
   - if <escrow-in>.precondition.tze_data_payload[<rl>_i] != <cust-close-out>.precondition.tze_data_payload[<rl>_i]:
    - Return False
   - if <escrow-id>.precondition.tze_data_payload[<cust-balance>_i] != <cust-close-out>.precondition.tze_data_payload[<cust-balance>_i]:
    - Return False
  - Return True
- if witness[0] = <mutual-close-tag>
  - <msg> = <pk_C> || <pk_M> || <cid> || <rl>_0 || <merch-balance>_0 || <cust-balance>_0 || <merch-balance>_m || <cust-balance>_m
  - if Verify(<pk_C>, <msg>, <signature_C>) = 0
   - Return False
  - if Verify(<pk_M>, <msg>, <signature_M>) = 0
   - Return False
  - if <merch-output>.amount != <merch-balance>_m OR <merch-output>.owner != <pk_M>:
   - Return False
  - if <cust-output>.amount != <cust-balance>_m  OR <cust-output>.owner != <pk_C>:
   - Return False
  - Return True
- Return False


B.2 Customer close
- if <cust-close-in>.witness.tze_data_payload = <cust-claim-tag>
   // Standard check (add delay if channel specific)
   - if sender != <pk_C>:
    - Return False
   - if context.<block-height> < <cust-close-tx-id>.<context>.<block-height>   DELAY // replace with channel specific delay if needs be
    - Return False
   - Return True
- if <cust-close-in>.witness.tze_data_payload[0] = <merch-dispute-tag>
   // Standard check (add delay if channel specific)
   - if sender != <pk_M>:
    - Return False
   - if <cust-close-tx-id>.pprecondition.tze_data_payload[prevout_in].<rl>_i != HASH(<cust-close-in>.witness.tze_data_payload.<rs>_i)
    - Return False
   - Return True
- Return False


B.3 Merchant close
- if <merch-close-in>.witness.tze_data_payload = <merch-claim-tag>
   // Standard check (add delay if channel specific)
   - if sender != <pk_M>:
    - Return False
   - if context.<block-height> < <merch-close-tx-id>.<context>.<block-height>   DELAY // replace with channel specific delay if needs be
    - Return False
   - Return True
- if <cust-close-out>.precondition.mode = <cust-close-mode>
   // Standard check (add delay if channel specific)
   - if sender != <pk_C>:
    - Return False
   - <msg> = <pk_C> || <pk_M> || <cid> || <rl>_i || <merch-balance>_i || <cust-balance>_i
   - if Verify(<pk_M>, <msg>, <signature_M>) = 0
    - Return False
   // Check that amounts and receiver are correct
   - if <merch-output>.amount != <merch-balance>_i OR <merch-output>.owner != <pk_M>:
    - Return False
   - if <cust-close-out>.amount != <cust-balance>_i OR <cust-close-out>.owner != <pk_C> OR <rl>_i NOT IN <cust-close-out>.precondition:
    - Return False
   // Check that information is transferred correctly from tze_in to tze_out
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<cid>] != <cust-close-out>.precondition.tze_data_payload[<cid>]:
    - Return False
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<pk_C>] != <cust-close-out>.precondition.tze_data_payload[<pk_C>]:
    - Return False
   - if <escrow-tx-id>.tze_in[prevout_in].precondition.tze_data_payload[<pk_M>] != <cust-close-out>.precondition.tze_data_payload[<pk_M>]:
    - Return False
   - if <escrow-in>.precondition.tze_data_payload[<rl>_i] != <cust-close-out>.precondition.tze_data_payload[<rl>_i]:
    - Return False
   - if <escrow-id>.precondition.tze_data_payload[<cust-balance>_i] != <cust-close-out>.precondition.tze_data_payload[<cust-balance>_i]:
    - Return False
   - Return True